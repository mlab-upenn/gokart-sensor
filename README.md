## ekf_python_dev

This is a sample branch to test the fusion of gnss and imu. 

When running in ros2:

- Each cmd should be invoked at the same time in different terminal(can use tmux).
- Remember to source **/opt/ros/foxy/setup.bash** and the workspace local **install/setup.bash** in each terminal.

### Test data and visualization

The data used for this fusion is a rosbag under `/test_bag` named `reduce2`(download [link](https://drive.google.com/drive/folders/1-yJjqYQzUi5mIfuDqV-4rB7B5WkquT6s?usp=share_link))

1.  Replay the rosbag

   Run `ros2 bag play reduce2/` inside the `/test_bag` folder.

2. Check ros2 topic list 

â€‹		Run `ros2 topic list`  in any terminal. The topic list should be like this:

```
/attcoveuler
/atteuler
/diagnostics
/gpgga
/gprmc
/gpsfix
/gpst
/imu/data
/imu/magnetometer
/measepoch
/navsatfix
/parameter_events
/poscovcartesian
/poscovgeodetic
/pose
/pvtcartesian
/pvtgeodetic
/rosout
/tf
/tf_static
/velcovgeodetic
```

3. Run plotjuggler([link](https://github.com/facontidavide/PlotJuggler)) to visualize the data. Check the basic usage in their README first(those are all we need)

Run `ros2 run plotjuggler plotjuggler` in any terminal.



### Run Sensor Fusion script

Run `ros2 launch ekf_gnss launch.py` in any terminal.

The fused pose is publish under `/gnss_ekf`, the original pose is publish under `/gnss_local`. Also use the plotjuggler to check them.

We do not have the ground truth in our hand in this case... However, the intuition is that the trajectory should be continuous and not jumping. The data points given by the gnss is discrete, the acceleration and yaw estimation from IMU is continuous.



### Task

What I am thinking to improve the package:

1. publish the velocity estimation from the IMU and check with the plotjuggler, check if it is good. The velocity estimation is generated by integrating the acceleration estimation. However, the acceleration estimation of IMU can be very noisy so I am not sure about the quality of the integration. 
2. Check the correct QOS profile we should use for the publisher and subscriber. The gnss is re-publisher by the`imu_listener` under `data_aug_ros2`. This is a cpp package and the publish quality is set to `10`. Not sure if it is the best choice, maybe compare other QOS profile?
3. The imu and gnss can arrive at different time but now the package is updating them together at one time-stamp. Also, there is one not correct timestamp update in the ekf updating function. Divyanshu kept it because it is a working version but I am not sure if it is ok
4. Check ESKF, do EKF in the error state
5. Reference(their code is good but can be more complex to understand the structure)

robot_localization_listener_node.cpp from `robot_localization`([link](https://github.com/cra-ros-pkg/robot_localization))

ekf_localizer from `autoware.universe` ([link](https://github.com/autowarefoundation/autoware.universe/tree/main/localization/ekf_localizer))

ekf_localizer from a developer in autoware([link](https://github.com/rsasaki0109/kalman_filter_localization)). He wrote the ekf for 3D pose so the state includes more information but the algorithm is similar.
